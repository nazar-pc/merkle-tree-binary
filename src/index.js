// Generated by LiveScript 1.5.0
/**
 * @package merkle-tree-binary
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  /**
   * @param {!Uint8Array} array1
   * @param {!Uint8Array} array2
   *
   * @return {!Uint8Array}
   */
  function concat(array1, array2){
    var length, x$;
    length = array1.length;
    x$ = new Uint8Array(length * 2);
    x$.set(array1);
    x$.set(array2, length);
    return x$;
  }
  /**
   * @param {!Uint8Array}	array1
   * @param {!Uint8Array}	array2
   *
   * @return {boolean}
   */
  function are_arrays_equal(array1, array2){
    var i$, len$, key, item;
    if (array1 === array2) {
      return true;
    }
    if (array1.length !== array2.length) {
      return false;
    }
    for (i$ = 0, len$ = array1.length; i$ < len$; ++i$) {
      key = i$;
      item = array1[i$];
      if (item !== array2[key]) {
        return false;
      }
    }
    return true;
  }
  /**
   * @param {!Array<!Uint8Array>}	items
   * @param {!Function}			hash_function
   */
  function get_root(items, hash_function){
    var item_length, new_items, res$, i$, len$, index, item1, item2;
    if (items.length === 1) {
      return items[0];
    } else {
      item_length = items[0].length;
      res$ = [];
      for (i$ = 0, len$ = items.length; i$ < len$; i$ += 2) {
        index = i$;
        item1 = items[i$];
        item2 = items[index + 1] || item1;
        res$.push(hash_function(concat(item1, item2)));
      }
      new_items = res$;
      return get_root(new_items, hash_function);
    }
  }
  /**
   * @param {!Array<!Uint8Array>}	items
   * @param {!Uint8Array}			target_item
   * @param {!Function}			hash_function
   * @param {!Array<number>}		proof
   *
   * @return {!Uint8Array}
   */
  function get_proof(items, target_item, hash_function, proof){
    var tree, i$, len$, index, item1, item2, hash;
    proof == null && (proof = []);
    if (items.length === 1) {
      return Uint8Array.from(proof);
    }
    tree = [];
    for (i$ = 0, len$ = items.length; i$ < len$; i$ += 2) {
      index = i$;
      item1 = items[i$];
      item2 = items[index + 1] || item1;
      hash = hash_function(concat(item1, item2));
      tree.push(hash);
      if (are_arrays_equal(item1, target_item)) {
        proof.concat(0, Array.from(item2));
        target_item = hash;
      } else if (are_arrays_equal(item2, target_item)) {
        proof.concat(1, Array.from(item1));
        target_item = hash;
      }
    }
    return get_proof(tree, target_item, hash_function, proof);
  }
  /**
   * @param {!Uint8Array}	root
   * @param {!Uint8Array}	proof
   * @param {!Uint8Array}	target_item
   * @param {!Function}	hash_function
   *
   * @return {boolean}
   */
  function check_proof(root, proof, target_item, hash_function){
    var item_length, proof_step, i$, to$, i, item;
    if (are_arrays_equal(root, target_item) && proof.length === 0) {
      return true;
    }
    item_length = target_item.length;
    if (proof.length % (item_length + 1)) {
      return false;
    }
    proof_step = item_length + 1;
    for (i$ = 0, to$ = proof.length; proof_step < 0 ? i$ > to$ : i$ < to$; i$ += proof_step) {
      i = i$;
      item = proof.subarray(i + 1, i + proof_step);
      if (proof[i]) {
        target_item = hash_function(concat(item, target_item));
      } else {
        target_item = hash_function(concat(target_item, item));
      }
    }
    return are_arrays_equal(root, target_item);
  }
  function Wrapper(){
    return {
      'get_root': get_root,
      'get_proof': get_proof,
      'check_proof': check_proof
    };
  }
  if (typeof define === 'function' && define['amd']) {
    define(Wrapper);
  } else if (typeof exports === 'object') {
    module.exports = Wrapper();
  } else {
    this['merkle_tree_binary'] = Wrapper();
  }
}).call(this);
